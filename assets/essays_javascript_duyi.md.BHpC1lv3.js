import{_ as a,c as e,o as r,a9 as t}from"./chunks/framework.D9nMkR03.js";const m=JSON.parse('{"title":"渡一大师课","description":"","frontmatter":{},"headers":[],"relativePath":"essays/javascript_duyi.md","filePath":"essays/javascript_duyi.md","lastUpdated":1711719606000}'),o={name:"essays/javascript_duyi.md"},p=t('<h1 id="渡一大师课" tabindex="-1">渡一大师课 <a class="header-anchor" href="#渡一大师课" aria-label="Permalink to &quot;渡一大师课&quot;">​</a></h1><p>本文为观看<a href="https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz" target="_blank" rel="noreferrer">渡一教育大师课</a>后，整理的线上面试题笔记，以供日常复习使用。</p><h2 id="一、原理-事件循环" tabindex="-1">一、原理 - 事件循环 <a class="header-anchor" href="#一、原理-事件循环" aria-label="Permalink to &quot;一、原理 - 事件循环&quot;">​</a></h2><p><code>单线程是异步产生的原因</code></p><p><code>事件循环是异步的实现方式</code></p><h3 id="如何理解-js-的异步" tabindex="-1">如何理解 JS 的异步？ <a class="header-anchor" href="#如何理解-js-的异步" aria-label="Permalink to &quot;如何理解 JS 的异步？&quot;">​</a></h3><p><img src="http://mdrs.yuanjin.tech/img/202208101043348.png" alt="image-20220810104344296"></p><p><img src="http://mdrs.yuanjin.tech/img/202208101048899.png" alt="image-20220810104858857"></p><p>JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。</p><p>这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体的做法是当某些任务发生时，比如计时器、网络、时间监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务书，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p><h3 id="阐述一下-js-的事件循环" tabindex="-1">阐述一下 JS 的事件循环 <a class="header-anchor" href="#阐述一下-js-的事件循环" aria-label="Permalink to &quot;阐述一下 JS 的事件循环&quot;">​</a></h3><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p><h3 id="js-中的计时器能够做到精确计时吗-为什么" tabindex="-1">JS 中的计时器能够做到精确计时吗？为什么？ <a class="header-anchor" href="#js-中的计时器能够做到精确计时吗-为什么" aria-label="Permalink to &quot;JS 中的计时器能够做到精确计时吗？为什么？&quot;">​</a></h3><p>不行，因为:</p><ol><li>计算机硬件没有原子钟，无法做到精确计时；</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差；</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少事件，这样在计时时间少于 4 毫秒时又带来了偏差；</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差。</li></ol><h2 id="二、原理-浏览器渲染原理" tabindex="-1">二、原理 - 浏览器渲染原理 <a class="header-anchor" href="#二、原理-浏览器渲染原理" aria-label="Permalink to &quot;二、原理 - 浏览器渲染原理&quot;">​</a></h2><h3 id="浏览器是如何渲染页面的" tabindex="-1">浏览器是如何渲染页面的？ <a class="header-anchor" href="#浏览器是如何渲染页面的" aria-label="Permalink to &quot;浏览器是如何渲染页面的？&quot;">​</a></h3><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><h4 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h4><p>整个渲染流程分为多个阶段，分别是： <strong>HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</strong></p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><h4 id="_1-html-解析-parse" tabindex="-1">1. HTML 解析（Parse） <a class="header-anchor" href="#_1-html-解析-parse" aria-label="Permalink to &quot;1. HTML 解析（Parse）&quot;">​</a></h4><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><h4 id="_2-样式计算-style" tabindex="-1">2. 样式计算（Style） <a class="header-anchor" href="#_2-样式计算-style" aria-label="Permalink to &quot;2. 样式计算（Style）&quot;">​</a></h4><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><h4 id="_3-布局-layout" tabindex="-1">3. 布局（Layout） <a class="header-anchor" href="#_3-布局-layout" aria-label="Permalink to &quot;3. 布局（Layout）&quot;">​</a></h4><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><h4 id="_4-分层-layer" tabindex="-1">4. 分层（Layer） <a class="header-anchor" href="#_4-分层-layer" aria-label="Permalink to &quot;4. 分层（Layer）&quot;">​</a></h4><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><h4 id="_5-绘制-paint" tabindex="-1">5. 绘制（Paint） <a class="header-anchor" href="#_5-绘制-paint" aria-label="Permalink to &quot;5. 绘制（Paint）&quot;">​</a></h4><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><h4 id="_6-分块-tiling" tabindex="-1">6. 分块（Tiling） <a class="header-anchor" href="#_6-分块-tiling" aria-label="Permalink to &quot;6. 分块（Tiling）&quot;">​</a></h4><p>再下一步是<strong>绘制</strong></p><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><h4 id="_7-光栅化-raster" tabindex="-1">7. 光栅化（Raster） <a class="header-anchor" href="#_7-光栅化-raster" aria-label="Permalink to &quot;7. 光栅化（Raster）&quot;">​</a></h4><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><h4 id="_8-画-draw" tabindex="-1">8. 画（Draw） <a class="header-anchor" href="#_8-画-draw" aria-label="Permalink to &quot;8. 画（Draw）&quot;">​</a></h4><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h3 id="什么是-reflow" tabindex="-1">什么是 Reflow？ <a class="header-anchor" href="#什么是-reflow" aria-label="Permalink to &quot;什么是 Reflow？&quot;">​</a></h3><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h3 id="什么是-repaint" tabindex="-1">什么是 Repaint？ <a class="header-anchor" href="#什么是-repaint" aria-label="Permalink to &quot;什么是 Repaint？&quot;">​</a></h3><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h3 id="为什么-transform-的效率高" tabindex="-1">为什么 Transform 的效率高？ <a class="header-anchor" href="#为什么-transform-的效率高" aria-label="Permalink to &quot;为什么 Transform 的效率高？&quot;">​</a></h3><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>',92),i=[p];function l(n,s,h,d,c,u){return r(),e("div",null,i)}const f=a(o,[["render",l]]);export{m as __pageData,f as default};
